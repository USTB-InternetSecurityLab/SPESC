/*
 * generated by Xtext 2.22.0
 */
package edu.ustb.sei.mde.serializer;

import com.google.inject.Inject;
import edu.ustb.sei.mde.services.SmartContractSpecificationGrammarAccess;
import edu.ustb.sei.mde.smartContractSpecification.ActionEnforcedTimeQuery;
import edu.ustb.sei.mde.smartContractSpecification.AdditiveExpression;
import edu.ustb.sei.mde.smartContractSpecification.AndExpression;
import edu.ustb.sei.mde.smartContractSpecification.Asset;
import edu.ustb.sei.mde.smartContractSpecification.Booleanconstant;
import edu.ustb.sei.mde.smartContractSpecification.BoundedTimePredicate;
import edu.ustb.sei.mde.smartContractSpecification.ComplexType;
import edu.ustb.sei.mde.smartContractSpecification.ConditionalExpression;
import edu.ustb.sei.mde.smartContractSpecification.Contract;
import edu.ustb.sei.mde.smartContractSpecification.Deposit;
import edu.ustb.sei.mde.smartContractSpecification.DescriptiveExpression;
import edu.ustb.sei.mde.smartContractSpecification.DutyTerm;
import edu.ustb.sei.mde.smartContractSpecification.ExternalParty;
import edu.ustb.sei.mde.smartContractSpecification.Field;
import edu.ustb.sei.mde.smartContractSpecification.FloatConstant;
import edu.ustb.sei.mde.smartContractSpecification.GlobalTimeQuery;
import edu.ustb.sei.mde.smartContractSpecification.GroupParty;
import edu.ustb.sei.mde.smartContractSpecification.ImplyExpression;
import edu.ustb.sei.mde.smartContractSpecification.IntegerConstant;
import edu.ustb.sei.mde.smartContractSpecification.IteratorDeclExpression;
import edu.ustb.sei.mde.smartContractSpecification.MoneyExpression;
import edu.ustb.sei.mde.smartContractSpecification.MultiplicativeExpression;
import edu.ustb.sei.mde.smartContractSpecification.NotExpression;
import edu.ustb.sei.mde.smartContractSpecification.OrExpression;
import edu.ustb.sei.mde.smartContractSpecification.PeriodicTimePredicate;
import edu.ustb.sei.mde.smartContractSpecification.QuantifierExpression;
import edu.ustb.sei.mde.smartContractSpecification.RelationalExpression;
import edu.ustb.sei.mde.smartContractSpecification.RightTerm;
import edu.ustb.sei.mde.smartContractSpecification.SelectExpression;
import edu.ustb.sei.mde.smartContractSpecification.Selection;
import edu.ustb.sei.mde.smartContractSpecification.SingleParty;
import edu.ustb.sei.mde.smartContractSpecification.SlotRef;
import edu.ustb.sei.mde.smartContractSpecification.SmartContractSpecificationPackage;
import edu.ustb.sei.mde.smartContractSpecification.StringConstant;
import edu.ustb.sei.mde.smartContractSpecification.TermValidTimeQuery;
import edu.ustb.sei.mde.smartContractSpecification.ThisExpression;
import edu.ustb.sei.mde.smartContractSpecification.TimeConstant;
import edu.ustb.sei.mde.smartContractSpecification.TimeLine;
import edu.ustb.sei.mde.smartContractSpecification.TimePredicate;
import edu.ustb.sei.mde.smartContractSpecification.TimeVarExpression;
import edu.ustb.sei.mde.smartContractSpecification.Transfer;
import edu.ustb.sei.mde.smartContractSpecification.Valueconstant;
import edu.ustb.sei.mde.smartContractSpecification.Withdraw;
import edu.ustb.sei.mde.smartContractSpecification.enumType;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SmartContractSpecificationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SmartContractSpecificationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SmartContractSpecificationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SmartContractSpecificationPackage.ACTION:
				sequence_Action(context, (edu.ustb.sei.mde.smartContractSpecification.Action) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.ACTION_ENFORCED_TIME_QUERY:
				sequence_ActionEnforcedTimeQuery(context, (ActionEnforcedTimeQuery) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.ADDITIVE_EXPRESSION:
				sequence_AdditiveExpression(context, (AdditiveExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.ASSET:
				sequence_Asset(context, (Asset) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.BOOLEANCONSTANT:
				sequence_ConstantExpression(context, (Booleanconstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.BOUNDED_TIME_PREDICATE:
				sequence_BoundedTimePredicate(context, (BoundedTimePredicate) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.COMPLEX_TYPE:
				sequence_ComplexType(context, (ComplexType) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.CONDITIONAL_EXPRESSION:
				sequence_ConditionalExpression(context, (ConditionalExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.DEPOSIT:
				sequence_TransferOperation(context, (Deposit) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.DESCRIPTIVE_EXPRESSION:
				sequence_DescriptiveExpression(context, (DescriptiveExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.DUTY_TERM:
				sequence_Term(context, (DutyTerm) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.EXTERNAL_PARTY:
				sequence_Party(context, (ExternalParty) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.FLOAT_CONSTANT:
				sequence_ConstantExpression(context, (FloatConstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.GLOBAL_TIME_QUERY:
				sequence_GlobalTimeQuery(context, (GlobalTimeQuery) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.GROUP_PARTY:
				sequence_Party(context, (GroupParty) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.IMPLY_EXPRESSION:
				sequence_ImplyExpression(context, (ImplyExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.INTEGER_CONSTANT:
				sequence_ConstantExpression(context, (IntegerConstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.ITERATOR_DECL_EXPRESSION:
				sequence_IteratorDeclExpression(context, (IteratorDeclExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.MONEY_EXPRESSION:
				sequence_MoneyExpression(context, (MoneyExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.MULTIPLICATIVE_EXPRESSION:
				sequence_MultiplicativeExpression(context, (MultiplicativeExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.OR_EXPRESSION:
				sequence_OrExpression(context, (OrExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.PERIODIC_TIME_PREDICATE:
				sequence_PeriodicTimePredicate(context, (PeriodicTimePredicate) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.QUANTIFIER_EXPRESSION:
				sequence_QuantifierExpression(context, (QuantifierExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.RELATIONAL_EXPRESSION:
				sequence_RelationalExpression(context, (RelationalExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.RIGHT_TERM:
				sequence_Term(context, (RightTerm) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.SELECT_EXPRESSION:
				sequence_CollectionSourceExpression(context, (SelectExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.SELECTION:
				sequence_Selection(context, (Selection) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.SINGLE_PARTY:
				sequence_Party(context, (SingleParty) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.SLOT_REF:
				sequence_SlotRef(context, (SlotRef) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.STRING_CONSTANT:
				sequence_ConstantExpression(context, (StringConstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.TERM_VALID_TIME_QUERY:
				sequence_TermValidTimeQuery(context, (TermValidTimeQuery) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.THIS_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getImplyExpressionRule()
						|| action == grammarAccess.getImplyExpressionAccess().getImplyExpressionConditionAction_1_0_0_0()
						|| rule == grammarAccess.getOrExpressionRule()
						|| action == grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionRule()
						|| action == grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getAndExpressionChildRule()
						|| rule == grammarAccess.getRelationalExpressionRule()
						|| action == grammarAccess.getRelationalExpressionAccess().getRelationalExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getArithmeticExpressionRule()
						|| rule == grammarAccess.getAdditiveExpressionRule()
						|| action == grammarAccess.getAdditiveExpressionAccess().getAdditiveExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getMultiplicativeExpressionRule()
						|| action == grammarAccess.getMultiplicativeExpressionAccess().getMultiplicativeExpressionLeftAction_1_0_0_0()
						|| rule == grammarAccess.getAtomExpressionRule()
						|| rule == grammarAccess.getThisExpressionRule()) {
					sequence_ThisExpression(context, (ThisExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTimeExpressionRule()
						|| rule == grammarAccess.getTimeThisExpressionRule()) {
					sequence_TimeThisExpression(context, (ThisExpression) semanticObject); 
					return; 
				}
				else break;
			case SmartContractSpecificationPackage.TIME_CONSTANT:
				sequence_TimeConstant(context, (TimeConstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.TIME_LINE:
				sequence_TimeLine(context, (TimeLine) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.TIME_PREDICATE:
				sequence_SimpleTimePredicate(context, (TimePredicate) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.TIME_VAR_EXPRESSION:
				sequence_TimeVarExpression(context, (TimeVarExpression) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.TRANSFER:
				sequence_TransferOperation(context, (Transfer) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.VALUECONSTANT:
				sequence_ConstantExpression(context, (Valueconstant) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.WITHDRAW:
				sequence_TransferOperation(context, (Withdraw) semanticObject); 
				return; 
			case SmartContractSpecificationPackage.ENUM_TYPE:
				sequence_enumType(context, (enumType) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns ActionEnforcedTimeQuery
	 *     ImplyExpression returns ActionEnforcedTimeQuery
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     OrExpression returns ActionEnforcedTimeQuery
	 *     OrExpression.OrExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     AndExpression returns ActionEnforcedTimeQuery
	 *     AndExpression.AndExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     AndExpressionChild returns ActionEnforcedTimeQuery
	 *     RelationalExpression returns ActionEnforcedTimeQuery
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     ArithmeticExpression returns ActionEnforcedTimeQuery
	 *     AdditiveExpression returns ActionEnforcedTimeQuery
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     MultiplicativeExpression returns ActionEnforcedTimeQuery
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns ActionEnforcedTimeQuery
	 *     AtomExpression returns ActionEnforcedTimeQuery
	 *     TimeExpression returns ActionEnforcedTimeQuery
	 *     TimeQuery returns ActionEnforcedTimeQuery
	 *     ActionEnforcedTimeQuery returns ActionEnforcedTimeQuery
	 *     TimeLineChild returns ActionEnforcedTimeQuery
	 *
	 * Constraint:
	 *     (multiplicity=ActionMultiplicity? party=[Party|ID] action=[Action|ID])
	 */
	protected void sequence_ActionEnforcedTimeQuery(ISerializationContext context, ActionEnforcedTimeQuery semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Action returns Action
	 *
	 * Constraint:
	 *     (name=ID (parameters+=Field parameters+=Field*)? type=[Type|ID]? (IsMany?='+' Times=INT?)?)
	 */
	protected void sequence_Action(ISerializationContext context, edu.ustb.sei.mde.smartContractSpecification.Action semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AdditiveExpression
	 *     ImplyExpression returns AdditiveExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns AdditiveExpression
	 *     OrExpression returns AdditiveExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns AdditiveExpression
	 *     AndExpression returns AdditiveExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns AdditiveExpression
	 *     AndExpressionChild returns AdditiveExpression
	 *     RelationalExpression returns AdditiveExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns AdditiveExpression
	 *     ArithmeticExpression returns AdditiveExpression
	 *     AdditiveExpression returns AdditiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns AdditiveExpression
	 *     MultiplicativeExpression returns AdditiveExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns AdditiveExpression
	 *     AtomExpression returns AdditiveExpression
	 *
	 * Constraint:
	 *     (left=AdditiveExpression_AdditiveExpression_1_0_0_0 operator=AdditiveOperator right=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, AdditiveExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.ADDITIVE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.ADDITIVE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getAdditiveExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getOperatorAdditiveOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getRightMultiplicativeExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     ImplyExpression returns AndExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns AndExpression
	 *     OrExpression returns AndExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns AndExpression
	 *     AndExpressionChild returns AndExpression
	 *     RelationalExpression returns AndExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns AndExpression
	 *     ArithmeticExpression returns AndExpression
	 *     AdditiveExpression returns AndExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns AndExpression
	 *     MultiplicativeExpression returns AndExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns AndExpression
	 *     AtomExpression returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0_0_0 right=AndExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightAndExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Asset returns Asset
	 *
	 * Constraint:
	 *     (name=ID fields+=Field* fields+=Field*)
	 */
	protected void sequence_Asset(ISerializationContext context, Asset semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BoundedTimePredicate
	 *     ImplyExpression returns BoundedTimePredicate
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns BoundedTimePredicate
	 *     OrExpression returns BoundedTimePredicate
	 *     OrExpression.OrExpression_1_0_0_0 returns BoundedTimePredicate
	 *     AndExpression returns BoundedTimePredicate
	 *     AndExpression.AndExpression_1_0_0_0 returns BoundedTimePredicate
	 *     AndExpressionChild returns BoundedTimePredicate
	 *     RelationalExpression returns BoundedTimePredicate
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns BoundedTimePredicate
	 *     ArithmeticExpression returns BoundedTimePredicate
	 *     AdditiveExpression returns BoundedTimePredicate
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns BoundedTimePredicate
	 *     MultiplicativeExpression returns BoundedTimePredicate
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns BoundedTimePredicate
	 *     AtomExpression returns BoundedTimePredicate
	 *     TimePredicate returns BoundedTimePredicate
	 *     BoundedTimePredicate returns BoundedTimePredicate
	 *
	 * Constraint:
	 *     (closed?='within'? bound=TimeExpression operator=TimePredicateOperator base=Expression)
	 */
	protected void sequence_BoundedTimePredicate(ISerializationContext context, BoundedTimePredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CollectionSourceExpression returns SelectExpression
	 *
	 * Constraint:
	 *     (source=CollectionSourceExpression_SelectExpression_1_0_0_0 condition=Expression)
	 */
	protected void sequence_CollectionSourceExpression(ISerializationContext context, SelectExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.COLLECTION_EXPRESSION__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.COLLECTION_EXPRESSION__SOURCE));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.SELECT_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.SELECT_EXPRESSION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCollectionSourceExpressionAccess().getSelectExpressionSourceAction_1_0_0_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getCollectionSourceExpressionAccess().getConditionExpressionParserRuleCall_1_1_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ComplexType returns ComplexType
	 *
	 * Constraint:
	 *     (name=ID fields+=Field*)
	 */
	protected void sequence_ComplexType(ISerializationContext context, ComplexType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ConditionalExpression
	 *     ConditionalExpression returns ConditionalExpression
	 *     ImplyExpression returns ConditionalExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns ConditionalExpression
	 *     OrExpression returns ConditionalExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns ConditionalExpression
	 *     AndExpression returns ConditionalExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns ConditionalExpression
	 *     AndExpressionChild returns ConditionalExpression
	 *     RelationalExpression returns ConditionalExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns ConditionalExpression
	 *     ArithmeticExpression returns ConditionalExpression
	 *     AdditiveExpression returns ConditionalExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns ConditionalExpression
	 *     MultiplicativeExpression returns ConditionalExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns ConditionalExpression
	 *     AtomExpression returns ConditionalExpression
	 *
	 * Constraint:
	 *     (condition=Expression thenBranch=Expression elseBranch=Expression)
	 */
	protected void sequence_ConditionalExpression(ISerializationContext context, ConditionalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__THEN_BRANCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__THEN_BRANCH));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__ELSE_BRANCH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.CONDITIONAL_EXPRESSION__ELSE_BRANCH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getThenBranchExpressionParserRuleCall_3_0(), semanticObject.getThenBranch());
		feeder.accept(grammarAccess.getConditionalExpressionAccess().getElseBranchExpressionParserRuleCall_5_0(), semanticObject.getElseBranch());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Booleanconstant
	 *     ImplyExpression returns Booleanconstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns Booleanconstant
	 *     OrExpression returns Booleanconstant
	 *     OrExpression.OrExpression_1_0_0_0 returns Booleanconstant
	 *     AndExpression returns Booleanconstant
	 *     AndExpression.AndExpression_1_0_0_0 returns Booleanconstant
	 *     AndExpressionChild returns Booleanconstant
	 *     RelationalExpression returns Booleanconstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns Booleanconstant
	 *     ArithmeticExpression returns Booleanconstant
	 *     AdditiveExpression returns Booleanconstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns Booleanconstant
	 *     MultiplicativeExpression returns Booleanconstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns Booleanconstant
	 *     AtomExpression returns Booleanconstant
	 *     ConstantExpression returns Booleanconstant
	 *
	 * Constraint:
	 *     value=Boolean
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, Booleanconstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.BOOLEANCONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.BOOLEANCONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueBooleanParserRuleCall_2_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns FloatConstant
	 *     ImplyExpression returns FloatConstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns FloatConstant
	 *     OrExpression returns FloatConstant
	 *     OrExpression.OrExpression_1_0_0_0 returns FloatConstant
	 *     AndExpression returns FloatConstant
	 *     AndExpression.AndExpression_1_0_0_0 returns FloatConstant
	 *     AndExpressionChild returns FloatConstant
	 *     RelationalExpression returns FloatConstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns FloatConstant
	 *     ArithmeticExpression returns FloatConstant
	 *     AdditiveExpression returns FloatConstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns FloatConstant
	 *     MultiplicativeExpression returns FloatConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns FloatConstant
	 *     AtomExpression returns FloatConstant
	 *     ConstantExpression returns FloatConstant
	 *
	 * Constraint:
	 *     value=Float
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, FloatConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.FLOAT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.FLOAT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueFloatParserRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns IntegerConstant
	 *     ImplyExpression returns IntegerConstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns IntegerConstant
	 *     OrExpression returns IntegerConstant
	 *     OrExpression.OrExpression_1_0_0_0 returns IntegerConstant
	 *     AndExpression returns IntegerConstant
	 *     AndExpression.AndExpression_1_0_0_0 returns IntegerConstant
	 *     AndExpressionChild returns IntegerConstant
	 *     RelationalExpression returns IntegerConstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns IntegerConstant
	 *     ArithmeticExpression returns IntegerConstant
	 *     AdditiveExpression returns IntegerConstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns IntegerConstant
	 *     MultiplicativeExpression returns IntegerConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns IntegerConstant
	 *     AtomExpression returns IntegerConstant
	 *     ConstantExpression returns IntegerConstant
	 *
	 * Constraint:
	 *     value=Integer
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, IntegerConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.INTEGER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.INTEGER_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueIntegerParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringConstant
	 *     ImplyExpression returns StringConstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns StringConstant
	 *     OrExpression returns StringConstant
	 *     OrExpression.OrExpression_1_0_0_0 returns StringConstant
	 *     AndExpression returns StringConstant
	 *     AndExpression.AndExpression_1_0_0_0 returns StringConstant
	 *     AndExpressionChild returns StringConstant
	 *     RelationalExpression returns StringConstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns StringConstant
	 *     ArithmeticExpression returns StringConstant
	 *     AdditiveExpression returns StringConstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns StringConstant
	 *     MultiplicativeExpression returns StringConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns StringConstant
	 *     AtomExpression returns StringConstant
	 *     ConstantExpression returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Valueconstant
	 *     ImplyExpression returns Valueconstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns Valueconstant
	 *     OrExpression returns Valueconstant
	 *     OrExpression.OrExpression_1_0_0_0 returns Valueconstant
	 *     AndExpression returns Valueconstant
	 *     AndExpression.AndExpression_1_0_0_0 returns Valueconstant
	 *     AndExpressionChild returns Valueconstant
	 *     RelationalExpression returns Valueconstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns Valueconstant
	 *     ArithmeticExpression returns Valueconstant
	 *     AdditiveExpression returns Valueconstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns Valueconstant
	 *     MultiplicativeExpression returns Valueconstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns Valueconstant
	 *     AtomExpression returns Valueconstant
	 *     ConstantExpression returns Valueconstant
	 *
	 * Constraint:
	 *     value='value'
	 */
	protected void sequence_ConstantExpression(ISerializationContext context, Valueconstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.VALUECONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.VALUECONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantExpressionAccess().getValueValueKeyword_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parties+=Party+ 
	 *         fields+=Field* 
	 *         terms+=Term* 
	 *         types+=ComplexType* 
	 *         assets+=Asset*
	 *     )
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DescriptiveExpression
	 *     DescriptiveExpression returns DescriptiveExpression
	 *     ImplyExpression returns DescriptiveExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns DescriptiveExpression
	 *     OrExpression returns DescriptiveExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns DescriptiveExpression
	 *     AndExpression returns DescriptiveExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns DescriptiveExpression
	 *     AndExpressionChild returns DescriptiveExpression
	 *     RelationalExpression returns DescriptiveExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns DescriptiveExpression
	 *     ArithmeticExpression returns DescriptiveExpression
	 *     AdditiveExpression returns DescriptiveExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns DescriptiveExpression
	 *     MultiplicativeExpression returns DescriptiveExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns DescriptiveExpression
	 *     AtomExpression returns DescriptiveExpression
	 *
	 * Constraint:
	 *     plainText=PLAINTEXT
	 */
	protected void sequence_DescriptiveExpression(ISerializationContext context, DescriptiveExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.DESCRIPTIVE_EXPRESSION__PLAIN_TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.DESCRIPTIVE_EXPRESSION__PLAIN_TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDescriptiveExpressionAccess().getPlainTextPLAINTEXTTerminalRuleCall_0(), semanticObject.getPlainText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID many?='set'? type=[Type|ID])
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GlobalTimeQuery
	 *     ImplyExpression returns GlobalTimeQuery
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns GlobalTimeQuery
	 *     OrExpression returns GlobalTimeQuery
	 *     OrExpression.OrExpression_1_0_0_0 returns GlobalTimeQuery
	 *     AndExpression returns GlobalTimeQuery
	 *     AndExpression.AndExpression_1_0_0_0 returns GlobalTimeQuery
	 *     AndExpressionChild returns GlobalTimeQuery
	 *     RelationalExpression returns GlobalTimeQuery
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns GlobalTimeQuery
	 *     ArithmeticExpression returns GlobalTimeQuery
	 *     AdditiveExpression returns GlobalTimeQuery
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns GlobalTimeQuery
	 *     MultiplicativeExpression returns GlobalTimeQuery
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns GlobalTimeQuery
	 *     AtomExpression returns GlobalTimeQuery
	 *     TimeExpression returns GlobalTimeQuery
	 *     TimeQuery returns GlobalTimeQuery
	 *     GlobalTimeQuery returns GlobalTimeQuery
	 *     TimeLineChild returns GlobalTimeQuery
	 *
	 * Constraint:
	 *     operator=TimeQueryOperator
	 */
	protected void sequence_GlobalTimeQuery(ISerializationContext context, GlobalTimeQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.GLOBAL_TIME_QUERY__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.GLOBAL_TIME_QUERY__OPERATOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGlobalTimeQueryAccess().getOperatorTimeQueryOperatorEnumRuleCall_0(), semanticObject.getOperator());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ImplyExpression
	 *     ImplyExpression returns ImplyExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns ImplyExpression
	 *     OrExpression returns ImplyExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns ImplyExpression
	 *     AndExpression returns ImplyExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns ImplyExpression
	 *     AndExpressionChild returns ImplyExpression
	 *     RelationalExpression returns ImplyExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns ImplyExpression
	 *     ArithmeticExpression returns ImplyExpression
	 *     AdditiveExpression returns ImplyExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns ImplyExpression
	 *     MultiplicativeExpression returns ImplyExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns ImplyExpression
	 *     AtomExpression returns ImplyExpression
	 *
	 * Constraint:
	 *     (condition=ImplyExpression_ImplyExpression_1_0_0_0 implied=Expression)
	 */
	protected void sequence_ImplyExpression(ISerializationContext context, ImplyExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.IMPLY_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.IMPLY_EXPRESSION__CONDITION));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.IMPLY_EXPRESSION__IMPLIED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.IMPLY_EXPRESSION__IMPLIED));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplyExpressionAccess().getImplyExpressionConditionAction_1_0_0_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getImplyExpressionAccess().getImpliedExpressionParserRuleCall_1_1_0(), semanticObject.getImplied());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IteratorDeclExpression returns IteratorDeclExpression
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_IteratorDeclExpression(ISerializationContext context, IteratorDeclExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIteratorDeclExpressionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MoneyExpression returns MoneyExpression
	 *
	 * Constraint:
	 *     condition=Expression
	 */
	protected void sequence_MoneyExpression(ISerializationContext context, MoneyExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.MONEY_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.MONEY_EXPRESSION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMoneyExpressionAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MultiplicativeExpression
	 *     ImplyExpression returns MultiplicativeExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns MultiplicativeExpression
	 *     OrExpression returns MultiplicativeExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns MultiplicativeExpression
	 *     AndExpression returns MultiplicativeExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns MultiplicativeExpression
	 *     AndExpressionChild returns MultiplicativeExpression
	 *     RelationalExpression returns MultiplicativeExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns MultiplicativeExpression
	 *     ArithmeticExpression returns MultiplicativeExpression
	 *     AdditiveExpression returns MultiplicativeExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns MultiplicativeExpression
	 *     MultiplicativeExpression returns MultiplicativeExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns MultiplicativeExpression
	 *     AtomExpression returns MultiplicativeExpression
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_MultiplicativeExpression_1_0_0_0 operator=MultiplicativeOperator right=AtomExpression)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, MultiplicativeExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.MULTIPLICATIVE_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.MULTIPLICATIVE_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.ARITHMETIC_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getMultiplicativeExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getOperatorMultiplicativeOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightAtomExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     ImplyExpression returns NotExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns NotExpression
	 *     OrExpression returns NotExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns NotExpression
	 *     AndExpression returns NotExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns NotExpression
	 *     AndExpressionChild returns NotExpression
	 *     NotExpression returns NotExpression
	 *     RelationalExpression returns NotExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns NotExpression
	 *     ArithmeticExpression returns NotExpression
	 *     AdditiveExpression returns NotExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns NotExpression
	 *     MultiplicativeExpression returns NotExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns NotExpression
	 *     AtomExpression returns NotExpression
	 *
	 * Constraint:
	 *     inner=RelationalExpression
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.NOT_EXPRESSION__INNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.NOT_EXPRESSION__INNER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getInnerRelationalExpressionParserRuleCall_1_0(), semanticObject.getInner());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     ImplyExpression returns OrExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns OrExpression
	 *     OrExpression returns OrExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns OrExpression
	 *     AndExpressionChild returns OrExpression
	 *     RelationalExpression returns OrExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns OrExpression
	 *     ArithmeticExpression returns OrExpression
	 *     AdditiveExpression returns OrExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns OrExpression
	 *     MultiplicativeExpression returns OrExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns OrExpression
	 *     AtomExpression returns OrExpression
	 *
	 * Constraint:
	 *     (left=OrExpression_OrExpression_1_0_0_0 right=OrExpression)
	 */
	protected void sequence_OrExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrExpressionAccess().getOrExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrExpressionAccess().getRightOrExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Party returns ExternalParty
	 *
	 * Constraint:
	 *     (name=ID (actions+=Action actions+=Action*)?)
	 */
	protected void sequence_Party(ISerializationContext context, ExternalParty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Party returns GroupParty
	 *
	 * Constraint:
	 *     (name=ID fields+=Field* actions+=Action*)
	 */
	protected void sequence_Party(ISerializationContext context, GroupParty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Party returns SingleParty
	 *
	 * Constraint:
	 *     (name=ID fields+=Field* actions+=Action*)
	 */
	protected void sequence_Party(ISerializationContext context, SingleParty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PeriodicTimePredicate
	 *     ImplyExpression returns PeriodicTimePredicate
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     OrExpression returns PeriodicTimePredicate
	 *     OrExpression.OrExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     AndExpression returns PeriodicTimePredicate
	 *     AndExpression.AndExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     AndExpressionChild returns PeriodicTimePredicate
	 *     RelationalExpression returns PeriodicTimePredicate
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     ArithmeticExpression returns PeriodicTimePredicate
	 *     AdditiveExpression returns PeriodicTimePredicate
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     MultiplicativeExpression returns PeriodicTimePredicate
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns PeriodicTimePredicate
	 *     AtomExpression returns PeriodicTimePredicate
	 *     TimePredicate returns PeriodicTimePredicate
	 *     PeriodicTimePredicate returns PeriodicTimePredicate
	 *
	 * Constraint:
	 *     ((operator=TimePredicateOperator periodDate=TimeConstant)? base=TimeConstant (period=TimeExpression | (basefrom=Expression baseto=Expression))?)
	 */
	protected void sequence_PeriodicTimePredicate(ISerializationContext context, PeriodicTimePredicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns QuantifierExpression
	 *     QuantifierExpression returns QuantifierExpression
	 *     ImplyExpression returns QuantifierExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns QuantifierExpression
	 *     OrExpression returns QuantifierExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns QuantifierExpression
	 *     AndExpression returns QuantifierExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns QuantifierExpression
	 *     AndExpressionChild returns QuantifierExpression
	 *     RelationalExpression returns QuantifierExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns QuantifierExpression
	 *     ArithmeticExpression returns QuantifierExpression
	 *     AdditiveExpression returns QuantifierExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns QuantifierExpression
	 *     MultiplicativeExpression returns QuantifierExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns QuantifierExpression
	 *     AtomExpression returns QuantifierExpression
	 *
	 * Constraint:
	 *     (qunatifier=Quantifier iterator=IteratorDeclExpression scope=CollectionSourceExpression condition=Expression)
	 */
	protected void sequence_QuantifierExpression(ISerializationContext context, QuantifierExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__QUNATIFIER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__QUNATIFIER));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__ITERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__ITERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__SCOPE));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.QUANTIFIER_EXPRESSION__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQuantifierExpressionAccess().getQunatifierQuantifierEnumRuleCall_0_0(), semanticObject.getQunatifier());
		feeder.accept(grammarAccess.getQuantifierExpressionAccess().getIteratorIteratorDeclExpressionParserRuleCall_1_0(), semanticObject.getIterator());
		feeder.accept(grammarAccess.getQuantifierExpressionAccess().getScopeCollectionSourceExpressionParserRuleCall_3_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getQuantifierExpressionAccess().getConditionExpressionParserRuleCall_6_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns RelationalExpression
	 *     ImplyExpression returns RelationalExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns RelationalExpression
	 *     OrExpression returns RelationalExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns RelationalExpression
	 *     AndExpression returns RelationalExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns RelationalExpression
	 *     AndExpressionChild returns RelationalExpression
	 *     RelationalExpression returns RelationalExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns RelationalExpression
	 *     ArithmeticExpression returns RelationalExpression
	 *     AdditiveExpression returns RelationalExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns RelationalExpression
	 *     MultiplicativeExpression returns RelationalExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns RelationalExpression
	 *     AtomExpression returns RelationalExpression
	 *
	 * Constraint:
	 *     (left=RelationalExpression_RelationalExpression_1_0_0_0 operator=RelationOperator right=ArithmeticExpression)
	 */
	protected void sequence_RelationalExpression(ISerializationContext context, RelationalExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.RELATIONAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRelationalExpressionLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getOperatorRelationOperatorEnumRuleCall_1_0_0_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getRelationalExpressionAccess().getRightArithmeticExpressionParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Selection returns Selection
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Selection(ISerializationContext context, Selection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.NAMED_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.NAMED_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSelectionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TimePredicate
	 *     ImplyExpression returns TimePredicate
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns TimePredicate
	 *     OrExpression returns TimePredicate
	 *     OrExpression.OrExpression_1_0_0_0 returns TimePredicate
	 *     AndExpression returns TimePredicate
	 *     AndExpression.AndExpression_1_0_0_0 returns TimePredicate
	 *     AndExpressionChild returns TimePredicate
	 *     RelationalExpression returns TimePredicate
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns TimePredicate
	 *     ArithmeticExpression returns TimePredicate
	 *     AdditiveExpression returns TimePredicate
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns TimePredicate
	 *     MultiplicativeExpression returns TimePredicate
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns TimePredicate
	 *     AtomExpression returns TimePredicate
	 *     TimePredicate returns TimePredicate
	 *     SimpleTimePredicate returns TimePredicate
	 *
	 * Constraint:
	 *     (operator=TimePredicateOperator base=Expression)
	 */
	protected void sequence_SimpleTimePredicate(ISerializationContext context, TimePredicate semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TIME_PREDICATE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TIME_PREDICATE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TIME_PREDICATE__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TIME_PREDICATE__BASE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleTimePredicateAccess().getOperatorTimePredicateOperatorEnumRuleCall_0_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSimpleTimePredicateAccess().getBaseExpressionParserRuleCall_1_0(), semanticObject.getBase());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SlotRef
	 *     CollectionSourceExpression returns SlotRef
	 *     CollectionSourceExpression.SelectExpression_1_0_0_0 returns SlotRef
	 *     ImplyExpression returns SlotRef
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns SlotRef
	 *     OrExpression returns SlotRef
	 *     OrExpression.OrExpression_1_0_0_0 returns SlotRef
	 *     AndExpression returns SlotRef
	 *     AndExpression.AndExpression_1_0_0_0 returns SlotRef
	 *     AndExpressionChild returns SlotRef
	 *     RelationalExpression returns SlotRef
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns SlotRef
	 *     ArithmeticExpression returns SlotRef
	 *     AdditiveExpression returns SlotRef
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns SlotRef
	 *     MultiplicativeExpression returns SlotRef
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns SlotRef
	 *     AtomExpression returns SlotRef
	 *     SlotRef returns SlotRef
	 *
	 * Constraint:
	 *     (slot=[DataSlot|ID] (transitive=TransitiveOperator? next=SlotRef)?)
	 */
	protected void sequence_SlotRef(ISerializationContext context, SlotRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TermValidTimeQuery
	 *     ImplyExpression returns TermValidTimeQuery
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns TermValidTimeQuery
	 *     OrExpression returns TermValidTimeQuery
	 *     OrExpression.OrExpression_1_0_0_0 returns TermValidTimeQuery
	 *     AndExpression returns TermValidTimeQuery
	 *     AndExpression.AndExpression_1_0_0_0 returns TermValidTimeQuery
	 *     AndExpressionChild returns TermValidTimeQuery
	 *     RelationalExpression returns TermValidTimeQuery
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns TermValidTimeQuery
	 *     ArithmeticExpression returns TermValidTimeQuery
	 *     AdditiveExpression returns TermValidTimeQuery
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns TermValidTimeQuery
	 *     MultiplicativeExpression returns TermValidTimeQuery
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns TermValidTimeQuery
	 *     AtomExpression returns TermValidTimeQuery
	 *     TimeExpression returns TermValidTimeQuery
	 *     TimeQuery returns TermValidTimeQuery
	 *     TermValidTimeQuery returns TermValidTimeQuery
	 *     TimeLineChild returns TermValidTimeQuery
	 *
	 * Constraint:
	 *     term=[Term|ID]
	 */
	protected void sequence_TermValidTimeQuery(ISerializationContext context, TermValidTimeQuery semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TERM_VALID_TIME_QUERY__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TERM_VALID_TIME_QUERY__TERM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermValidTimeQueryAccess().getTermTermIDTerminalRuleCall_0_0_1(), semanticObject.eGet(SmartContractSpecificationPackage.Literals.TERM_VALID_TIME_QUERY__TERM, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Term returns DutyTerm
	 *
	 * Constraint:
	 *     (
	 *         auto?='auto'? 
	 *         break?='break'? 
	 *         name=ID 
	 *         party=[Party|ID] 
	 *         action=[Action|ID] 
	 *         condition=Expression? 
	 *         transferOperations+=TransferOperation* 
	 *         postCondition=Expression? 
	 *         breachOperations+=TransferOperation*
	 *     )
	 */
	protected void sequence_Term(ISerializationContext context, DutyTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Term returns RightTerm
	 *
	 * Constraint:
	 *     (
	 *         auto?='auto'? 
	 *         break?='break'? 
	 *         name=ID 
	 *         party=[Party|ID] 
	 *         action=[Action|ID] 
	 *         condition=Expression? 
	 *         transferOperations+=TransferOperation* 
	 *         postCondition=Expression?
	 *     )
	 */
	protected void sequence_Term(ISerializationContext context, RightTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ThisExpression
	 *     ImplyExpression returns ThisExpression
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns ThisExpression
	 *     OrExpression returns ThisExpression
	 *     OrExpression.OrExpression_1_0_0_0 returns ThisExpression
	 *     AndExpression returns ThisExpression
	 *     AndExpression.AndExpression_1_0_0_0 returns ThisExpression
	 *     AndExpressionChild returns ThisExpression
	 *     RelationalExpression returns ThisExpression
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns ThisExpression
	 *     ArithmeticExpression returns ThisExpression
	 *     AdditiveExpression returns ThisExpression
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns ThisExpression
	 *     MultiplicativeExpression returns ThisExpression
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns ThisExpression
	 *     AtomExpression returns ThisExpression
	 *     ThisExpression returns ThisExpression
	 *
	 * Constraint:
	 *     (transitive=TransitiveOperator? next=SlotRef)?
	 */
	protected void sequence_ThisExpression(ISerializationContext context, ThisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TimeConstant
	 *     ImplyExpression returns TimeConstant
	 *     ImplyExpression.ImplyExpression_1_0_0_0 returns TimeConstant
	 *     OrExpression returns TimeConstant
	 *     OrExpression.OrExpression_1_0_0_0 returns TimeConstant
	 *     AndExpression returns TimeConstant
	 *     AndExpression.AndExpression_1_0_0_0 returns TimeConstant
	 *     AndExpressionChild returns TimeConstant
	 *     RelationalExpression returns TimeConstant
	 *     RelationalExpression.RelationalExpression_1_0_0_0 returns TimeConstant
	 *     ArithmeticExpression returns TimeConstant
	 *     AdditiveExpression returns TimeConstant
	 *     AdditiveExpression.AdditiveExpression_1_0_0_0 returns TimeConstant
	 *     MultiplicativeExpression returns TimeConstant
	 *     MultiplicativeExpression.MultiplicativeExpression_1_0_0_0 returns TimeConstant
	 *     AtomExpression returns TimeConstant
	 *     TimeExpression returns TimeConstant
	 *     TimeLineChild returns TimeConstant
	 *     TimeConstant returns TimeConstant
	 *
	 * Constraint:
	 *     (
	 *         year=INT? 
	 *         month=INT? 
	 *         day=INT? 
	 *         hour=INT? 
	 *         min=INT? 
	 *         sec=INT? 
	 *         date=INT?
	 *     )
	 */
	protected void sequence_TimeConstant(ISerializationContext context, TimeConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeExpression returns TimeLine
	 *     TimeLine returns TimeLine
	 *
	 * Constraint:
	 *     (base=TimeLineChild operator=TimeLineOperator deviation=TimeLineChild)
	 */
	protected void sequence_TimeLine(ISerializationContext context, TimeLine semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__BASE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__BASE));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__DEVIATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TIME_LINE__DEVIATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeLineAccess().getBaseTimeLineChildParserRuleCall_0_0(), semanticObject.getBase());
		feeder.accept(grammarAccess.getTimeLineAccess().getOperatorTimeLineOperatorEnumRuleCall_1_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getTimeLineAccess().getDeviationTimeLineChildParserRuleCall_2_0(), semanticObject.getDeviation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TimeExpression returns ThisExpression
	 *     TimeThisExpression returns ThisExpression
	 *
	 * Constraint:
	 *     (transitive=TransitiveOperator? next=SlotRef)?
	 */
	protected void sequence_TimeThisExpression(ISerializationContext context, ThisExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeExpression returns TimeVarExpression
	 *     TimeVarExpression returns TimeVarExpression
	 *
	 * Constraint:
	 *     (slot=[DataSlot|ID] next=SlotRef?)
	 */
	protected void sequence_TimeVarExpression(ISerializationContext context, TimeVarExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TransferOperation returns Deposit
	 *
	 * Constraint:
	 *     money=MoneyExpression
	 */
	protected void sequence_TransferOperation(ISerializationContext context, Deposit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransferOperationAccess().getMoneyMoneyExpressionParserRuleCall_0_2_0(), semanticObject.getMoney());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransferOperation returns Transfer
	 *
	 * Constraint:
	 *     (money=MoneyExpression account=Expression)
	 */
	protected void sequence_TransferOperation(ISerializationContext context, Transfer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY));
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER__ACCOUNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER__ACCOUNT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransferOperationAccess().getMoneyMoneyExpressionParserRuleCall_2_2_0(), semanticObject.getMoney());
		feeder.accept(grammarAccess.getTransferOperationAccess().getAccountExpressionParserRuleCall_2_4_0(), semanticObject.getAccount());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransferOperation returns Withdraw
	 *
	 * Constraint:
	 *     money=MoneyExpression
	 */
	protected void sequence_TransferOperation(ISerializationContext context, Withdraw semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SmartContractSpecificationPackage.Literals.TRANSFER_OPERATION__MONEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransferOperationAccess().getMoneyMoneyExpressionParserRuleCall_1_2_0(), semanticObject.getMoney());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     enumType returns enumType
	 *
	 * Constraint:
	 *     (name=ID selections+=Selection selections+=Selection*)
	 */
	protected void sequence_enumType(ISerializationContext context, enumType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
