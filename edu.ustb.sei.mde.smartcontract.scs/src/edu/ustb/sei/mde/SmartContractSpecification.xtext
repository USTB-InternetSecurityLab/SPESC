// automatically generated by Xtext
grammar edu.ustb.sei.mde.SmartContractSpecification with org.eclipse.xtext.common.Terminals

import "platform:/resource/edu.ustb.sei.mde.smartcontract/model/smartContract.ecore" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Contract returns Contract:
	'contract'
	name=ID
	'{'
		parties+=Party+
		fields+=Field*
		(terms+=Term '.')*
		types+=ComplexType*
		assets+=Asset*
	'}';

ComplexType returns ComplexType :
	'type' name=ID '{' fields+=Field*'}'
;

Asset returns Asset :
	'asset' name=ID '{'
		'info' '{'
			fields+=Field*
		'}'
		'right' '{'
			fields+=Field*
		'}'
	'}'
;

enumType returns enumType :
	'enum' name = ID '{'selections += Selection (','selections += Selection)*'}'
;

Selection returns Selection :
	name = ID
;

Field returns Field :
	name=ID ':' many?='set'? type=[Type|ID] (SLD)? 
;

Party returns Party:
  {SingleParty} 'party' name=ID '{' fields+=Field* actions+=Action* '}'
| {GroupParty} 'party' 'group' name=ID '{' fields+=Field* actions+=Action* '}'
| {ExternalParty} 'external' 'party' name=ID '{' (actions+=Action (',' actions+=Action)*)? '}'
;

Action returns Action :
  name=ID '(' (parameters+=Field (',' parameters+=Field)*)? ')' (':' type=[Type|ID])? SLD? (IsMany ?= '+' (Times = INT)?)?
;

Term returns Term :
 {RightTerm} (auto ?= 'auto')? (break ?= 'break')? 'term' name=ID ':' party=[Party|ID] 'can' action=[Action|ID] ','? ('when' condition=Expression)? ('while' transferOperations+=TransferOperation+)? ('where' postCondition=Expression)? 
| {DutyTerm} (auto ?= 'auto')? (break ?= 'break')? 'term' name=ID ':' party=[Party|ID] 'must' action=[Action|ID] ','? ('when' condition=Expression)? ('while' transferOperations+=TransferOperation+)? ('where' postCondition=Expression)? ('breach' breachOperations+=TransferOperation+)?
;

TransferOperation returns TransferOperation:
{Deposit} 'deposit' money=MoneyExpression
| {Withdraw} 'withdraw' money=MoneyExpression
| {Transfer} 'transfer' money=MoneyExpression 'to' account=Expression
;

MoneyExpression returns MoneyExpression :
	{MoneyExpression}'$' /*('value'( name = ID)? relationOperator = RelationOperator)?*/ condition=Expression
;


Expression returns Expression :
ConditionalExpression
| => ImplyExpression
;

DescriptiveExpression returns DescriptiveExpression: 
plainText=PLAINTEXT
;


CollectionSourceExpression returns CollectionSourceExpression :
	SlotRef (=> ({SelectExpression.source=current} 'where') condition=Expression)?
;

IteratorDeclExpression returns IteratorDeclExpression :
	name=ID
;

QuantifierExpression returns QuantifierExpression:
	qunatifier=Quantifier iterator=IteratorDeclExpression 'in' scope=CollectionSourceExpression 'such' 'that' condition=Expression
;

enum Quantifier returns Quantifier :
	forAll='all' | forAll='forAll' | exists='some' | exists='exists'
;


ConditionalExpression returns ConditionalExpression :
  'if' condition=Expression 'then' thenBranch=Expression 'else' elseBranch=Expression
;

ImplyExpression returns Expression :
  OrExpression (=> ({ImplyExpression.condition=current} 'implies') implied=Expression)? 
;

OrExpression returns Expression: 
   AndExpression (=>({OrExpression.left=current} ('or'|'||') ) right=OrExpression)?
;

AndExpression returns Expression :
  AndExpressionChild (=>({AndExpression.left=current} ('and'|'&&') ) right=AndExpression)?
;

AndExpressionChild returns Expression:
NotExpression
| RelationalExpression
;

NotExpression returns NotExpression :
  'not' inner=RelationalExpression
;

RelationalExpression returns Expression :
  ArithmeticExpression (=> ({RelationalExpression.left=current} operator=RelationOperator) right=ArithmeticExpression)?
;

enum RelationOperator returns RelationalOperator :
	equal='=' | equal='is' | less='<' | lessOrEqual='<=' | greater='>' | greaterOrEqual='>=' | notEqual ='!=' | notEqual ='<>' | notEqual ='isn\'t'
;

ArithmeticExpression returns Expression:
AdditiveExpression
;

AdditiveExpression returns Expression:
   MultiplicativeExpression (=>({AdditiveExpression.left=current} operator=AdditiveOperator) right=MultiplicativeExpression)?
;

enum AdditiveOperator returns AdditiveOperator :
	add='+' | sub='-'
;

MultiplicativeExpression returns Expression:
   AtomExpression (=>({MultiplicativeExpression.left=current} operator=MultiplicativeOperator) right=AtomExpression)?
;

enum MultiplicativeOperator returns MultiplicativeOperator :
	mul='*' | div='/'
;

AtomExpression returns Expression:
=> ConstantExpression
| TimePredicate
| SlotRef
| ThisExpression
| QuantifierExpression
| DescriptiveExpression
| GlobalTimeQuery
| TimeConstant
| TimeQuery
| '(' Expression ')'
;

ThisExpression returns ThisExpression :
{ThisExpression}	 (('this' (ID)?) | 'he' | 'she' | 'his' | 'her' | 'himself' | 'herself') ('::' transitive=TransitiveOperator? next=SlotRef)?
;


SlotRef returns SlotRef :
	slot=[DataSlot|ID] ('::' transitive=TransitiveOperator? next=SlotRef)?
;

enum TransitiveOperator returns TransitiveOperator :
	transitiveEnclosure='^' | selfTransitiveEnclosure='*'
;

ConstantExpression returns Expression:
  {IntegerConstant} value=Integer
| {StringConstant} value=STRING
| {Booleanconstant} value=Boolean
| {FloatConstant} value=Float
| {Valueconstant} value="value"
;



Float returns ecore::EFloat :
	('+'|'-')? (INT '.' INT? | '.' INT)
;
Integer returns ecore::EInt :
	('-')? INT
;

Boolean returns ecore::EBoolean :
	'true' | 'false'
;

TimePredicate returns TimePredicate :
SimpleTimePredicate
| => BoundedTimePredicate
| => PeriodicTimePredicate
;

SimpleTimePredicate returns TimePredicate :
	operator=TimePredicateOperator base=Expression
;

//边界时间谓词
BoundedTimePredicate returns BoundedTimePredicate :
	closed?='within'? bound=TimeExpression operator=TimePredicateOperator base=Expression
;
//周期时间谓词
PeriodicTimePredicate returns PeriodicTimePredicate :
	 'by' (operator=TimePredicateOperator periodDate = TimeConstant)? 'every' base=TimeConstant 
	 (('in' period= TimeExpression)| ('from' basefrom = Expression 'to' baseto = Expression ))?
;

enum TimePredicateOperator returns TimePredicateOperator:
	before='before' | after='after' 
;

TimeExpression returns TimeExpression :
=>TimeLine
| TimeConstant
| TimeQuery
| TimeVarExpression
| TimeThisExpression
;

TimeQuery returns TimeQuery:
  ActionEnforcedTimeQuery
| TermValidTimeQuery
| GlobalTimeQuery
;

ActionEnforcedTimeQuery returns ActionEnforcedTimeQuery:
	multiplicity=ActionMultiplicity? party=[Party|ID] 'did' action=[Action|ID]
;

enum ActionMultiplicity returns PartyMemberMultiplicity :
	all='all' | any="any" | any="some" | any="one" | this='this' | this="the"
;

TermValidTimeQuery returns TermValidTimeQuery:
	term=[Term|ID] 'is' 'valid'
;

GlobalTimeQuery returns GlobalTimeQuery:
	operator = TimeQueryOperator 
;

TimeLine returns TimeLine :
  base=TimeLineChild operator=TimeLineOperator deviation=TimeLineChild
;

TimeLineChild returns TimeExpression :
TimeConstant
| TimeQuery

;

enum TimeLineOperator returns TimeLineOperator :
	forward='+' | backward='-'
;

enum TimeQueryOperator returns TimeQueryOperator:
	now='now' | contractStart='start' | contractEnd='end'
; 



TimeConstant returns TimeConstant :
 {TimeConstant} (year=INT 'year')? (month=INT 'month')? (day=INT 'day')? (hour=INT 'hour')? (min=INT 'min')? (sec=INT 'sec')?(date = INT 'th') ? 
;


TimeVarExpression returns TimeVarExpression:
  '@' slot=[DataSlot|ID] ('::'  next=SlotRef)?
;

TimeThisExpression returns ThisExpression :
{ThisExpression}	 '@'(('this' ID) | 'he' | 'she' | 'his' | 'her' | 'himself' | 'herself') ('::' transitive=TransitiveOperator? next=SlotRef)?
;


terminal SLD :
  'i.e.,' !('\n'|'\r')* ('\r'? '\n')?
;
terminal SL_COMMENT:
    ('@@'|'//') !('\n'|'\r')* ('\r'? '\n')?;
    
terminal PLAINTEXT :
  "#" ( '\\' . | !('\\'|"#") )* "#"
;
